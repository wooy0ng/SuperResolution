# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13HK8bhBTUXDZfIKlVdNyHMim1wrYIqDq
"""

import cv2
import math
import numpy as np
import random
import torch
import imgaug.augmenters as ia
from PIL import Image

from scipy import special
from scipy import ndimage
from scipy.stats import multivariate_normal
from scipy.linalg import orth

import PIL.Image as pil_image


class Degradation:
    def __init__(self, sf=4):
        self.sf = sf
        self.blur_kernel_size = 21
        self.kernel_list = [
            "iso",
            "aniso",
            "generalized_iso",
            "generalized_aniso",
            "plateau_iso",
            "plateau_aniso",
        ]
        self.kernel_prob = [0.45, 0.25, 0.12, 0.03, 0.12, 0.03]
        self.blur_sigma = [0.2, 3]
        self.betag_range = [0.5, 3]
        self.betap_range = [1, 2]
        self.sinc_prob = 0.1
        self.updown_type = ["up", "down", "keep"]
        self.mode_list = ["area", "bilinear", "bicubic"]
        self.resize_prob = [0.2, 0.7, 0.1]
        self.resize_range = [0.15, 1.5]

        # blur settings for the second degradation
        self.blur_kernel_size2 = 21
        self.kernel_list2 = [
            "iso",
            "aniso",
            "generalized_iso",
            "generalized_aniso",
            "plateau_iso",
            "plateau_aniso",
        ]
        self.kernel_prob2 = [0.45, 0.25, 0.12, 0.03, 0.12, 0.03]
        self.blur_sigma2 = [0.2, 1.5]
        self.betag_range2 = [0.5, 4]
        self.betap_range2 = [1, 2]
        self.sinc_prob2 = 0.1
        self.resize_prob2 = [0.3, 0.4, 0.3]
        self.resize_range2 = [0.3, 1.2]

        self.final_sinc_prob = 0.8

        self.kernel_range = [
            2 * v + 1 for v in range(3, 11)
        ]  # kernel size ranges from 7 to 21
        self.pulse_tensor = torch.zeros(
            21, 21
        ).float()  # convolving with pulse tensor brings no blurry effect
        self.pulse_tensor[10, 10] = 1

    def uint2single(self, img):
        return np.float32(img / 255.0)

    def single2uint(self, img):
        return np.uint8((img.clip(0, 1) * 255.0).round())

    def degradation_pipeline(self, image):
        image = self.uint2single(np.array(image))
        hq = image.copy()

        # first
        image = self.generate_kernel1(image)
        image = self.generate_sinc(image)

        image = self.random_resizing1(image)

        image = self.add_Gaussian_noise(image)
        image = self.add_Poisson_noise(image)

        image = self.add_JPEG_noise(image)

        # second
        image = self.generate_kernel2(image)

        image = self.random_resizing2(image)

        image = self.add_Poisson_noise(image)
        
        image = self.add_Gaussian_noise(image)

        if np.random.uniform() < 0.5:
            image = self.generate_sinc(image)
            image = self.add_JPEG_noise(image)
        else:
            image = self.add_JPEG_noise(image)
            image = self.generate_sinc(image)

        # resize to desired size
        image = cv2.resize(
            image,
            (int(1 / self.sf * hq.shape[1]), int(1 / self.sf * hq.shape[0])),
            interpolation=random.choice([1, 2, 3]),
        )

        image = self.single2uint(image)
        return image

    def add_Poisson_noise(self, img):
        img = np.clip((img * 255.0).round(), 0, 255) / 255.0
        vals = 10 ** (2 * random.random() + 2.0)  # [2, 4]
        if random.random() < 0.5:
            img = np.random.poisson(img * vals).astype(np.float32) / vals
        else:
            img_gray = np.dot(img[..., :3], [0.299, 0.587, 0.114])
            img_gray = np.clip((img_gray * 255.0).round(), 0, 255) / 255.0
            noise_gray = (
                np.random.poisson(img_gray * vals).astype(np.float32) / vals - img_gray
            )
            img += noise_gray[:, :, np.newaxis]
        img = np.clip(img, 0.0, 1.0)
        return img

    def add_Gaussian_noise(self, img, noise_level1=2, noise_level2=25):
        noise_level = random.randint(noise_level1, noise_level2)
        rnum = np.random.rand()
        if rnum > 0.6:  # add color Gaussian noise
            img += np.random.normal(0, noise_level / 255.0, img.shape).astype(
                np.float32
            )
        elif rnum < 0.4:  # add grayscale Gaussian noise
            img += np.random.normal(0, noise_level / 255.0, (*img.shape[:2], 1)).astype(
                np.float32
            )
        else:  # add  noise
            L = noise_level2 / 255.0
            D = np.diag(np.random.rand(3))
            U = orth(np.random.rand(3, 3))
            conv = np.dot(np.dot(np.transpose(U), D), U)
            img += np.random.multivariate_normal(
                [0, 0, 0], np.abs(L ** 2 * conv), img.shape[:2]
            ).astype(np.float32)
        img = np.clip(img, 0.0, 1.0)
        return img

    def add_JPEG_noise(self, img):
        quality_factor = random.randint(30, 95)
        img = cv2.cvtColor(self.single2uint(img), cv2.COLOR_RGB2BGR)
        result, encimg = cv2.imencode(
            ".jpg", img, [int(cv2.IMWRITE_JPEG_QUALITY), quality_factor]
        )
        img = cv2.imdecode(encimg, 1)
        img = cv2.cvtColor(self.uint2single(img), cv2.COLOR_BGR2RGB)
        return img

    def add_sharpening(self, img, weight=0.5, radius=50, threshold=10):
        if radius % 2 == 0:
            radius += 1
        blur = cv2.GaussianBlur(img, (radius, radius), 0)
        residual = img - blur
        mask = np.abs(residual) * 255 > threshold
        mask = mask.astype("float32")
        soft_mask = cv2.GaussianBlur(mask, (radius, radius), 0)

        K = img + weight * residual
        K = np.clip(K, 0, 1)
        return soft_mask * K + (1 - soft_mask) * img

    def random_resizing1(self, image):
        h, w, c = image.shape

        updown_type = random.choices(self.updown_type, self.resize_prob)
        mode = random.choice(self.mode_list)

        if updown_type == "up":
            scale = np.random.uniform(1, self.resize_range[1])
        elif updown_type == "down":
            scale = np.random.uniform(self.resize_range[0], 1)
        else:
            scale = 1

        if mode == "area":
            flags = cv2.INTER_AREA
        elif mode == "bilinear":
            flags = cv2.INTER_LINEAR
        elif mode == "bicubic":
            flags = cv2.INTER_CUBIC

        image = cv2.resize(image, (int(w * scale), int(h * scale)), interpolation=flags)
        image = cv2.resize(image, (w, h), interpolation=flags)
        image = np.clip(image, 0.0, 1.0)
        return image

    def random_resizing2(self, image):
        h, w, c = image.shape
        updown_type = random.choices(self.updown_type, self.resize_prob2)
        mode = random.choice(self.mode_list)

        if updown_type == "up":
            scale = np.random.uniform(1, self.resize_range2[1])
        elif updown_type == "down":
            scale = np.random.uniform(self.resize_range2[0], 1)
        else:
            scale = 1

        if mode == "area":
            flags = cv2.INTER_AREA
        elif mode == "bilinear":
            flags = cv2.INTER_LINEAR
        elif mode == "bicubic":
            flags = cv2.INTER_CUBIC

        image = cv2.resize(image, (int(w * scale), int(h * scale)), interpolation=flags)
        image = cv2.resize(image, (w, h), interpolation=flags)
        image = np.clip(image, 0.0, 1.0)
        return image

    def generate_kernel1(self, image):
        kernel_size = random.choice(self.kernel_range)
        kernel = self.random_mixed_kernels(
            self.kernel_list,
            self.kernel_prob,
            kernel_size,
            self.blur_sigma,
            self.blur_sigma,
            [-math.pi, math.pi],
            self.betag_range,
            self.betap_range,
            noise_range=None,
        )

        # pad kernel
        pad_size = (21 - kernel_size) // 2
        kernel = np.pad(kernel, ((pad_size, pad_size), (pad_size, pad_size)))

        image = ndimage.filters.convolve(
            image, np.expand_dims(kernel, axis=2), mode="reflect"
        )
        return image.clip(min=0, max=255)

    def generate_kernel2(self, image):
        kernel_size = random.choice(self.kernel_range)
        kernel2 = self.random_mixed_kernels(
            self.kernel_list2,
            self.kernel_prob2,
            kernel_size,
            self.blur_sigma2,
            self.blur_sigma2,
            [-math.pi, math.pi],
            self.betag_range2,
            self.betap_range2,
            noise_range=None,
        )

        # pad kernel
        pad_size = (21 - kernel_size) // 2
        kernel = np.pad(kernel2, ((pad_size, pad_size), (pad_size, pad_size)))

        image = ndimage.filters.convolve(
            image, np.expand_dims(kernel, axis=2), mode="reflect"
        )
        return image.clip(min=0, max=255)

    def generate_sinc(self, image):
        sinc_kernel = self.pulse_tensor

        image = ndimage.filters.convolve(
            image, np.expand_dims(sinc_kernel, axis=2), mode="reflect"
        )
        return image.clip(min=0, max=255)

    def sigma_matrix2(self, sig_x, sig_y, theta):
        D = np.array([[sig_x ** 2, 0], [0, sig_y ** 2]])
        U = np.array([[np.cos(theta), -np.sin(theta)], [np.sin(theta), np.cos(theta)]])
        return np.dot(U, np.dot(D, U.T))

    def mesh_grid(self, kernel_size):
        ax = np.arange(-kernel_size // 2 + 1.0, kernel_size // 2 + 1.0)
        xx, yy = np.meshgrid(ax, ax)
        xy = np.hstack(
            (
                xx.reshape((kernel_size * kernel_size, 1)),
                yy.reshape(kernel_size * kernel_size, 1),
            )
        ).reshape(kernel_size, kernel_size, 2)
        return xy, xx, yy

    def pdf2(self, sigma_matrix, grid):
        inverse_sigma = np.linalg.inv(sigma_matrix)
        kernel = np.exp(-0.5 * np.sum(np.dot(grid, inverse_sigma) * grid, 2))
        return kernel

    def cdf2(D, grid):
        rv = multivariate_normal([0, 0], [[1, 0], [0, 1]])
        grid = np.dot(grid, D)
        cdf = rv.cdf(grid)
        return cdf

    def bivariate_Gaussian(
        self, kernel_size, sig_x, sig_y, theta, grid=None, isotropic=True
    ):
        if grid is None:
            grid, _, _ = self.mesh_grid(kernel_size)
        if isotropic:
            sigma_matrix = np.array([[sig_x ** 2, 0], [0, sig_x ** 2]])
        else:
            sigma_matrix = self.sigma_matrix2(sig_x, sig_y, theta)
        kernel = self.pdf2(sigma_matrix, grid)
        kernel = kernel / np.sum(kernel)
        return kernel

    def bivariate_generalized_Gaussian(
        self, kernel_size, sig_x, sig_y, theta, beta, grid=None, isotropic=True
    ):
        if grid is None:
            grid, _, _ = self.mesh_grid(kernel_size)
        if isotropic:
            sigma_matrix = np.array([[sig_x ** 2, 0], [0, sig_x ** 2]])
        else:
            sigma_matrix = self.sigma_matrix2(sig_x, sig_y, theta)
        inverse_sigma = np.linalg.inv(sigma_matrix)
        kernel = np.exp(
            -0.5 * np.power(np.sum(np.dot(grid, inverse_sigma) * grid, 2), beta)
        )
        kernel = kernel / np.sum(kernel)
        return kernel

    def bivariate_plateau(
        self, kernel_size, sig_x, sig_y, theta, beta, grid=None, isotropic=True
    ):
        if grid is None:
            grid, _, _ = self.mesh_grid(kernel_size)
        if isotropic:
            sigma_matrix = np.array([[sig_x ** 2, 0], [0, sig_x ** 2]])
        else:
            sigma_matrix = self.sigma_matrix2(sig_x, sig_y, theta)
        inverse_sigma = np.linalg.inv(sigma_matrix)
        kernel = np.reciprocal(
            np.power(np.sum(np.dot(grid, inverse_sigma) * grid, 2), beta) + 1
        )
        kernel = kernel / np.sum(kernel)
        return kernel

    def random_bivariate_Gaussian(
        self,
        kernel_size,
        sigma_x_range,
        sigma_y_range,
        rotation_range,
        noise_range=None,
        isotropic=True,
    ):
        assert kernel_size % 2 == 1, "Kernel size must be an odd number."
        assert sigma_x_range[0] < sigma_x_range[1], "Wrong sigma_x_range."
        sigma_x = np.random.uniform(sigma_x_range[0], sigma_x_range[1])
        if isotropic is False:
            assert sigma_y_range[0] < sigma_y_range[1], "Wrong sigma_y_range."
            assert rotation_range[0] < rotation_range[1], "Wrong rotation_range."
            sigma_y = np.random.uniform(sigma_y_range[0], sigma_y_range[1])
            rotation = np.random.uniform(rotation_range[0], rotation_range[1])
        else:
            sigma_y = sigma_x
            rotation = 0

        kernel = self.bivariate_Gaussian(
            kernel_size, sigma_x, sigma_y, rotation, isotropic=isotropic
        )

        # add multiplicative noise
        if noise_range is not None:
            assert noise_range[0] < noise_range[1], "Wrong noise range."
            noise = np.random.uniform(noise_range[0], noise_range[1], size=kernel.shape)
            kernel = kernel * noise
        kernel = kernel / np.sum(kernel)
        return kernel

    def random_bivariate_generalized_Gaussian(
        self,
        kernel_size,
        sigma_x_range,
        sigma_y_range,
        rotation_range,
        beta_range,
        noise_range=None,
        isotropic=True,
    ):
        assert kernel_size % 2 == 1, 
        assert sigma_x_range[0] < sigma_x_range[1], 
        sigma_x = np.random.uniform(sigma_x_range[0], sigma_x_range[1])
        if isotropic is False:
            assert sigma_y_range[0] < sigma_y_range[1], 
            assert rotation_range[0] < rotation_range[1], 
            sigma_y = np.random.uniform(sigma_y_range[0], sigma_y_range[1])
            rotation = np.random.uniform(rotation_range[0], rotation_range[1])
        else:
            sigma_y = sigma_x
            rotation = 0

        # assume beta_range[0] < 1 < beta_range[1]
        if np.random.uniform() < 0.5:
            beta = np.random.uniform(beta_range[0], 1)
        else:
            beta = np.random.uniform(1, beta_range[1])

        kernel = self.bivariate_generalized_Gaussian(
            kernel_size, sigma_x, sigma_y, rotation, beta, isotropic=isotropic
        )

        # add multiplicative noise
        if noise_range is not None:
            assert noise_range[0] < noise_range[1], 
            noise = np.random.uniform(noise_range[0], noise_range[1], size=kernel.shape)
            kernel = kernel * noise
        kernel = kernel / np.sum(kernel)
        return kernel

    def random_bivariate_plateau(
        self,
        kernel_size,
        sigma_x_range,
        sigma_y_range,
        rotation_range,
        beta_range,
        noise_range=None,
        isotropic=True,
    ):
        
        assert kernel_size % 2 == 1, 
        assert sigma_x_range[0] < sigma_x_range[1], 
        sigma_x = np.random.uniform(sigma_x_range[0], sigma_x_range[1])
        if isotropic is False:
            assert sigma_y_range[0] < sigma_y_range[1], 
            assert rotation_range[0] < rotation_range[1], 
            sigma_y = np.random.uniform(sigma_y_range[0], sigma_y_range[1])
            rotation = np.random.uniform(rotation_range[0], rotation_range[1])
        else:
            sigma_y = sigma_x
            rotation = 0

        
        if np.random.uniform() < 0.5:
            beta = np.random.uniform(beta_range[0], 1)
        else:
            beta = np.random.uniform(1, beta_range[1])

        kernel = self.bivariate_plateau(
            kernel_size, sigma_x, sigma_y, rotation, beta, isotropic=isotropic
        )
        # add multiplicative noise
        if noise_range is not None:
            assert noise_range[0] < noise_range[1], "Wrong noise range."
            noise = np.random.uniform(noise_range[0], noise_range[1], size=kernel.shape)
            kernel = kernel * noise
        kernel = kernel / np.sum(kernel)

        return kernel

    def random_mixed_kernels(
        self,
        kernel_list,
        kernel_prob,
        kernel_size=21,
        sigma_x_range=[0.6, 5],
        sigma_y_range=[0.6, 5],
        rotation_range=[-math.pi, math.pi],
        betag_range=[0.5, 8],
        betap_range=[0.5, 8],
        noise_range=None,
    ):
        kernel_type = random.choices(kernel_list, kernel_prob)[0]
        if kernel_type == "iso":
            kernel = self.random_bivariate_Gaussian(
                kernel_size,
                sigma_x_range,
                sigma_y_range,
                rotation_range,
                noise_range=noise_range,
                isotropic=True,
            )
        elif kernel_type == "aniso":
            kernel = self.random_bivariate_Gaussian(
                kernel_size,
                sigma_x_range,
                sigma_y_range,
                rotation_range,
                noise_range=noise_range,
                isotropic=False,
            )
        elif kernel_type == "generalized_iso":
            kernel = self.random_bivariate_generalized_Gaussian(
                kernel_size,
                sigma_x_range,
                sigma_y_range,
                rotation_range,
                betag_range,
                noise_range=noise_range,
                isotropic=True,
            )
        elif kernel_type == "generalized_aniso":
            kernel = self.random_bivariate_generalized_Gaussian(
                kernel_size,
                sigma_x_range,
                sigma_y_range,
                rotation_range,
                betag_range,
                noise_range=noise_range,
                isotropic=False,
            )
        elif kernel_type == "plateau_iso":
            kernel = self.random_bivariate_plateau(
                kernel_size,
                sigma_x_range,
                sigma_y_range,
                rotation_range,
                betap_range,
                noise_range=None,
                isotropic=True,
            )
        elif kernel_type == "plateau_aniso":
            kernel = self.random_bivariate_plateau(
                kernel_size,
                sigma_x_range,
                sigma_y_range,
                rotation_range,
                betap_range,
                noise_range=None,
                isotropic=False,
            )
        return kernel

    def circular_lowpass_kernel(self, cutoff, kernel_size, pad_to=0):
        assert kernel_size % 2 == 1, 
        kernel = np.fromfunction(
            lambda x, y: cutoff
            * special.j1(
                cutoff
                * np.sqrt(
                    (x - (kernel_size - 1) / 2) ** 2 + (y - (kernel_size - 1) / 2) ** 2
                )
            )
            / (
                2
                * np.pi
                * np.sqrt(
                    (x - (kernel_size - 1) / 2) ** 2 + (y - (kernel_size - 1) / 2) ** 2
                )
            ),
            [kernel_size, kernel_size],
        )
        kernel[(kernel_size - 1) // 2, (kernel_size - 1) // 2] = cutoff ** 2 / (
            4 * np.pi
        )
        kernel = kernel / np.sum(kernel)
        if pad_to > kernel_size:
            pad_size = (pad_to - kernel_size) // 2
            kernel = np.pad(kernel, ((pad_size, pad_size), (pad_size, pad_size)))
        return kernel

deg = Degradation()


# i 로 degrade 횟수 지정 
for i in range(1):
      print(i)
      img = pil_image.open("/content/OST/ADE_train_00000935.png").convert("RGB")
      sf = 4
      img_lq = deg.degradation_pipeline(img)
      img = pil_image.fromarray(img_lq)
      img.save(f"OST-{30}.png")